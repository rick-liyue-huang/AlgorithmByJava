
## Algorithm by Java

#### LinearSearch

循环不变量： 确保算法在运行中保持不变的部分要一致
复杂度分析： 分为 空间复杂性 和 空间复杂性

##### 常见的复杂度

表示算法的性能 通常是看最差的情况
O(n): T = c1 * n + c2 也就是线性的关系，一次的关系
常数不重要，复杂度描述是随着数据规模n的增大，算法性能的变化趋势

对于 二级嵌套循环有 O(n^2)

O(log2 n) 例如 将数字n转变为二进制 n /= 2
O(log10 n) 例如 将数字n转化为 十进制 n /= 10

```
while (n) {
    n % 2; // 得到二进制中的一位
    n /= 2;
}
```

数字n的所有约数 O(sqrt(n))

```
for (int i = 1; i <= n; i++) {
    if (n % i == 0) // 得到一个约数
}

for (int i = 1; i *  <= n; i++) {
    if (n % i == 0) // 得到两个约数 i 和 n/i 
}
```

长度为n的二进制数字： O(2^n)
长度为n的数组的排列 O(n!)

判断数字是否是偶数 return n % 2 == 0 O(1)

总体而言：
O(1) < O(log n) < O(sqrt(n)) < O(n) < O(nlog n) < O(n^2) < O(2^n) < O(n!)

用空间换时间
尽量处理时间的复杂度


#### sort 排序

##### selection sort

从原来的数组中取出最小的，依次循环取出最小的，这个是需要额外的开辟空间

可以进行 原地排序

循环不变量：
arr[i, ... n) 未排序
arr[0, ... i) 已排序  循环不变量
arr[i, ... n) 中最小值要放到 arr[i] 的位置上

##### Insertion sort

循环不变量：
arr[i, ... n) 未排序
arr[0, ... i) 已排序  循环不变量
把 arr[i] 放入到合适的位置

对于有序的数组，其复杂度是 O(n), 整体来说复杂度还是 O(n^2)


#### Data Constructure

数据结构研究的是数据如何在计算机中进行组织和存储，使得我们可以高效的获取数据或者修改数据

线性结构：数组，栈，队列，链表，哈希表
树结构：二叉树，二分搜索树，AVL，红黑树，堆，K-D树，Treap，Splay，线段树
图结构：连接矩阵，连接表

##### Array

把数据排成一排进行存放，每个数据都有位置编号，编号从0开始
数组的优点：快速查询
数组最好应用于索引有语意的情况
并非所有的有寓意的索引可以作为数组的索引，例如身份证号






